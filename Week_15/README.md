# 课程所涉及的技术关键点的思考与经验认识

### 1 JVM

JVM(**Java virtual machine** ) 顾名思义是一种虚拟机，可以运行翻译成Java字节码文件的代码，不仅仅是java语言。JVM 有自己的规范，不同的平台有不同的实现，相同的代码翻译成字节码之后可以运行在不同平台的JVM上，实现了一次编写到处运行。JVM提供了内存管理 垃圾回收功能，用户不用过多操心程序内存管理问题，这是Java可以广泛应用的重要条件之一。JVM是介于应用与操作系统之间的平台。

### 2 NIO

IO模型 分为 同步非同步 阻塞与非阻塞

1. **同步：** 你打电话后不挂电话，等前台给你去查询可以安排的时间，直到前台回复你预约结果
2. **异步：** 你打电话告诉前台之后，立即挂断电话，然后前台安排好了以后 再电话回拨给你告知你预约结果
3. **阻塞：** 你打了电话，在没拿到结果之前你什么都没做，一直在沙发上干着急的等待。
4. **非阻塞：** 你打了电话之后，继续干别的事，然后每隔一段时间查一下结果

Netty是一款网络应用程序框架，可以基于netty开发网络通信方面的服务器端或客户端的应用程序，应用非常广泛，如

1. 一些常用的中间件使用netty作为网络通信的基础服务，譬如阿里开源的RPC通信框架：Apache Dubbo，Dubbo协议就是基于Netty扩展的自定义协议，就是使用Netty作为各进程间进行网络通信的；譬如RocketMQ 生产者和消费者之间的通信也是基于Netty开发的。
2. 游戏领域作为游戏服务器的数据通信开发
3. 大数据领域作为节点之间数据交换的通信框架

netty在中间件当中的应用非常广泛，如果要研究dubbo rocketmq这些中间件的源码，io的原理 和netty是绕不过去的。



### 3 并发编程

并发编程是充分利用机器性能的手段，充分发挥多核CPU的优势。Java里面的并发编程技术本质上都是操作系统里面管程的模型，主要的核心问题有三个，分工，同步，互斥。分工 是分配线程，同步是线程间如何协作，互斥 是保证同一时刻只允许一个线程访问共享资源。并发编程的学习需要多参考一些固定的编码模式 和 并发包的工具类，尽量减少错误和提高效率。

### 4 Spring 和 ORM 等框架

Spring等Java框架 主要目的是用来简化编码工作的，Spring的出现是为了干掉复杂的EJB的，Spring framework的核心是IOC和AOP, IOC管理对象，AOP抽象共同代码，大大简化了编码的复杂性，是JAVA在后端领域大行其道的关键技术之一。随着Spring的发展，整合了越来越多的规范和技术，变得越来越臃肿，曾经的屠龙少年变成了恶龙了。于是Spring boot这个手脚架出现了，做了大量的默认配置，采用约定大于配置的思路，简化了Spring的开发。

ORM封装了通过JDBC的操作数据库，简化了程序对sql的操作。hibernate 及JPA 是想屏蔽服务端对具体数据库的依赖，封装了JAVA操作的数据库的基本规范函数，做到java与具体的SQL解耦，但是比较难应对复杂的场景。而且SQL效率也难优化，Mybatis的优缺点则正好相反，与具体的SQL关联，优点是比较灵活，比较可以应付较复杂的SQL场景

### 5 MySQL 数据库和 SQL

关系型数据库从曾经的一统天下，到现在与NoSQL分庭抗礼 ，但依然是数据兜底的保障，一般的业务系统 主要性能瓶颈可能都出在SQL的性能上，业务开发的主要工作 CRUD，掌握好SQL的基本原理和使用是非常重要的，SQL的主从模式和高可用模式与其他分布式中间件的思路是一致的：基本都是多副本策略，采用投票选主等方式。

### 6 分库分表

分库分表分为垂直拆分和水平拆分，垂直拆分拆业务 拆表结构，水平拆分 拆数据，原来同一个表数据 拆分到多个相同表结构的表或库中。拆了之后会引入分布式事务问题，跨节点join问题，合并排序分页等等问题。针对数据源的管理可以分为客户端模式和代理模式，客户端模式比较简单，不依赖中间件，减少性能损耗，缺点是客户端需要配置，有不可控的风险，数据库连接处理比较复杂。代表有sharding-jdbc; 代理模式 是通过中间件代理层统一管理数据源，客户端使用无感，缺点是依赖中间件，有二次性能损耗。

拆分原则：能不拆就不拆，少join, 尽量避免分布式事务  

数据迁移 rehash是个头疼的问题，首次直接分片干到最大 说不定是个好方案

### 7 RPC 和微服务

RPC（远程过程调用）将远程调用看起来像本地调用一样。客户端 所得到的服务的接口实例不是服务端真正的实现类的实例，而是基于RPC框架提供的代理类实例，stub。不同的RPC框架stub生成的方式不一样，RPC有服务注册与发现的过程，客户端寻址这些过程 与消息队列的实现非常类似。

在客户端和服务端，收发请求响应的工作都是 RPC 框架来实现的，所以，只要 RPC 框架保证在不同的编程语言中，使用相同的序列化协议，就可以实现跨语言的通信。

一个完善的RPC框架不仅仅是实现远程过程调用这么简单，包括了服务提供者，客户端，服务注册与发现中心，服务运行的容器 和监控等等。

微服务是各服务之间是独立的的应用，服务之间是可以跨语言的，职责单一的，异步通信的，服务与服务之间的通信既可以基于RPC也可以是restful的，微服务是SOA架构的基础上演进的，具有更细的粒度，倾向于去中心化的部署。微服务也不是银弹，微服务会引入服务治理困难，分布式事务，数据一致性 跨节点调用等等问题，服务之间的协调复杂度比较高，一般是可以用单体就用单体，业务规模扩大，复杂度变高以后 再考虑拆分。

### 8 分布式缓存

缓存是为了加快数据的处理速度引入的非永久性的冗余数据。内存缓存是把热点数据，静态数据等数据缓存到内存中，避免直接访问磁盘，大大提高访问效率。分布式缓存是相对于单体而言的，单体可以使用本地缓存，譬如map数据结构，缓存 需要考虑数据一致性，读写比，命中率这些问题，命中率太低 设置缓存没有意义，写太频繁也不合适，也会加剧一致性的误差。缓存的思想无处不在，cpu的cache , nginx，mybatis 等等。分布式缓存主要的思路是各服务都集中的使用同一个远程的缓存，譬如多个机器的应用同访问同一个redis实例。

### 9 分布式消息队列

分布式消息队列是为了异步 解耦  流量削峰而生的，一般就是生产者与消费者模式，有三个角色

1. producer 负责生产消息
2. broker 负责存储和转发消息
3. consumer 负责消费消息

一般有两种模式  主题模式和队列模式，队列模式 消息入队后 只可能被被一个消费者消费掉了； 主题模式 一份消息可以被订阅了该消息的消费组消费同时消费。一般使用消息队列都需要考虑几个问题，如何确保消息不丢失，如何防止消息重复消费，消息积压了怎么办等等这些问题。